# Ring-Polymer Molecular Dynamics (RPMD)

Comparison between **quantum mechanical**, **ring-polymer molecular dynamics**, and **classical** simulations of a particle in a simple 1D anharmonic potential. Implements RPMD following Craig & Manolopoulos (2004) with utilities to compute **Kubo-transformed real-time correlation functions**.

> Please cite: I. R. Craig & D. E. Manolopoulos (2004), *Quantum statistics and classical mechanics: Real time correlation functions from ring polymer molecular dynamics*, **J. Chem. Phys. 121, 3368–3373**.

---

## Features

* Classical MD baseline (**n = 1** bead) and full **RPMD** (**n ≥ 1**)
* Kubo-transformed correlation functions $\tilde C_{AB}(t)$ for position-dependent observables
* Correct short-time quantum limit and detailed-balance symmetry
* Modular integrators (velocity-Verlet) and thermostats
* Reproducible examples for harmonic and anharmonic test systems

---

## Theory

### 1) Quantum–classical isomorphism of the partition function

For a 1D system with $\hat H=\hat p^{2}/2m+V(\hat x)$, the quantum canonical partition function


$Z=\mathrm{tr}\left[e^{-\beta \hat H}\right]$


is **isomorphic** to the classical partition function of an $n$-bead ring polymer:


$Z=\lim_{n\to\infty} Z_n,\qquad
Z_n=\frac{1}{(2\pi\hbar)^n}\int d\mathbf p\int d\mathbf xe^{-\beta_n H_n(\mathbf p,\mathbf x)}\quad \beta_n=\beta/n$,

with ring-polymer Hamiltonian


$H_n(\mathbf p,\mathbf x)=\sum_{j=1}^{n}\frac{p_j^2}{2m}
+\frac{m}{2\beta_n^{2}\hbar^{2}}\sum_{j=1}^{n}(x_j-x_{j-1})^{2}
+\sum_{j=1}^{n}V(x_j),\qquad x_0\equiv x_n$

**Bead-averaged estimator (position observables):**


$z\langle A\rangle=\lim_{n\to\infty}\frac{1}{(2\pi\hbar)^n Z_n}!\int d\mathbf p, d\mathbf x;
e^{-\beta_n H_n}, A_n(\mathbf x),\quad
A_n(\mathbf x)=\frac{1}{n}\sum_{j=1}^{n}A(x_j)$.

---

### 2) Kubo-transformed correlation function and the RPMD estimator

The **Kubo-transformed** real-time correlation function is


$\tilde C_{AB}(t)=\frac{1}{\beta Z}\int_0^\beta d\lambda;
\mathrm{tr}!\Big[e^{-(\beta-\lambda)\hat H},\hat A, e^{-\lambda \hat H},
e^{+i\hat H t/\hbar},\hat B, e^{-i\hat H t/\hbar}\Big]$.

It obeys


$\tilde C_{AB}(t)=\tilde C_{BA}(-t)=\tilde C_{AB}(t)^{*}$,

so $\tilde C_{AB}(t)$ is **real and even** .

**RPMD approximation.** Evolve the $n$-bead ring polymer under classical Hamiltonian dynamics generated by $H_n$ and use bead-averaged estimators:
$$
\boxed{
\langle A(0)B(t)\rangle_n
=\frac{1}{(2\pi\hbar)^n Z_n}
!\int d\mathbf p_0, d\mathbf x_0;
e^{-\beta_n H_n(\mathbf p_0,\mathbf x_0)},
A_n(\mathbf x_0), B_n(\mathbf x_t)
}
$$
where $(\mathbf p_t,\mathbf x_t)$ are obtained from Hamilton’s equations for $H_n$.
This reproduces the **exact** quantum $\tilde C_{AB}(t)$ at $t=0$ and satisfies detailed balance by construction.

**Harmonic exactness.** For $V(x)=\tfrac{1}{2}m\omega^{2}x^{2}$ and $A$ or $B$ linear in $x$,
$$
\tilde C_{Ax}(t)=\tilde C_{Ax}(0)\cos(\omega t),
$$
and the RPMD estimator yields this **exactly**.

---

## Build & Run (Fortran)

Requires a modern Fortran compiler (e.g., `gfortran >= 10`). A simple CMake flow:

```bash
mkdir -p build && cd build
cmake .. -DCMAKE_BUILD_TYPE=Release
cmake --build . -j
ctest --output-on-failure
```

### Minimal example (harmonic oscillator)

```fortran
program rpmd_harmonic
  use rpmd_core
  implicit none
  integer, parameter :: nbeads = 32
  real(8), parameter :: beta = 10.0d0, dt = 5.0d-4
  type(rpmd_state) :: S

  call rpmd_init(S, nbeads=nbeads, beta=beta, potential=>V_harmonic)
  call rpmd_sample(S)                        ! draw (p,x) ~ exp(-beta_n H_n)
  call rpmd_propagate(S, dt, nsteps=200000)  ! integrate dynamics
  call rpmd_kubo_accumulate(S, A=>pos, B=>pos, tmax=50.0d0)
  call rpmd_write_results(S, 'outputs/harmonic_pospos.dat')
  call rpmd_finalize(S)

contains
  pure subroutine V_harmonic(x, v, f)
    real(8), intent(in)  :: x(:)   ! bead positions
    real(8), intent(out) :: v(:)   ! V(x_j) for each bead
    real(8), intent(out) :: f(:)   ! dV/dx_j for each bead
    real(8), parameter :: m=1.0d0, w=1.0d0
    v = 0.5d0*m*w*w*x*x
    f = m*w*w*x
  end subroutine

  pure function pos(x) result(a)
    real(8), intent(in) :: x(:)
    real(8) :: a
    a = sum(x)/size(x)             ! bead-average position
  end function
end program
```

> The API above is illustrative; see `examples/` for working programs that match the library interface.

---

## When it works best

* **Short times** $t \lesssim \beta\hbar$ where quantum statistics dominate
* **Low temperatures** and **mild anharmonicity** (marked improvement over classical MD)
* Not designed to capture long-time quantum coherence in strongly anharmonic 1D models

---

## License

MIT (or your preference).
